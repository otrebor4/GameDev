'''
Created on Jan 22, 2014

@author: otrebor
'''
import game.util.Vector2 as Vector2
import game.phys.shapes


class CollisionInfo:
    def __init__(self):
        self.shape1 = None
        self.shape2 = None
        self.edge = (Vector2.Vector2(),Vector2.Vector2())
        

#fast aabb overlap check
def checkAABBOverlap(obj1, obj2):
    aabb1 = obj1.gameObject.shape.calAABB() if obj1.gameObject.shape != None else None
    aabb2 = obj2.gameObject.shape.calAABB() if obj2.gameObject.shape != None else None
    
    if aabb1 == None or aabb2 == None: #missing at least one shape can't collide
        return False
    
    return not ( aabb1[2] < aabb2[0] or
                 aabb1[0] > aabb2[2] or
                 aabb1[3] > aabb2[1] or
                 aabb1[1] < aabb2[3] )



#return a collisionInfo if happen or None if not collision detected

def testCollision( obj1, obj2):
    if not checkAABBOverlap(obj1, obj2):
        return None
    shape1 = obj1.gameObject.shape
    shape2 = obj2.gameObject.shape
    
    #circle circle collision
    if isinstance(shape1, game.phys.shapes.Circle.Circle) and isinstance(shape2, game.phys.shapes.Circle.Circle):
        return testCircleCircle(obj1, obj2)
        
    #polygon polygon collision
    if isinstance(shape1, game.phys.shapes.Polygon.Polygon) and isinstance(shape2,game.phys.shapes.Polygon.Polygon):
        return testPolygonSat(obj1, obj2)
        pass
    #polygon-circle collision
    if isinstance(shape1, game.phys.shapes.Circle.Circle):
        pass
    else:
        pass
    
    
def testCircleCircle(c1, c2):
    totalRadius = c1.radius + c2.radius
    distSqr =  c1.position.distanceSq(c2.position )
    if distSqr > totalRadius * totalRadius:
        return None
    else:
        info = CollisionInfo()
        info.shape1 = c1
        info.shape2 = c2
        info.edge = ( c1.position, c2.position)
        return info
    
    
def testPolygonSat(p1, p2):
    
    
    
#obj1 and obj2 are GameObjects, edge is a (Vector2, Vector2)

def HandleCollision(obj1, obj2, edge):
    #only riged component respond to collision
    rig1 = obj1.riged   
    rig2 = obj2.riged
    
    if rig1 == None and rig2 == None: #why try to handle collision they don't respond to collision
        return 
    normal = edge[1].sub(edge[0]).normal()
        
    v1 = rig1.velocity if rig1 != None else Vector2.Vector2()
    ns1 = normal.dot(v1)
    v1x = normal.scale(ns1)
    v1y = v1.sub(v1x)
        
    normal.scale(-1)
    
    v2 = rig2.velocity if rig2 != None else Vector2.Vector2()
    ns2 = normal.dot(v2)
    v2x = normal.scale(ns2)
    v2y = v2.sub(v2x)
    
    if rig2 == None:
        rig1.velocity = v1x.add(v1y)
    elif rig1 == None:
        rig2.velocity = v2x.add(v2y)
    else:   
        m1 = rig1.mass if rig1 != None else INF
        m2 = rig2.mass if rig2 != None else INF
        cm = m1 + m2
        rig1.velocity = v1x.scale( (m1-m2) /cm).add(v2x.scale( (2*m2)/cm)).add(v1y)
        rig2.velocity = v1x.scale( (2 *m1) /cm).add(v2x.scale( (m2-m1)/cm)).add(v2y)
    
    '''
    x = c1.pos().sub(c2.pos())
    x = x.normalize()
        v1 = c1.speed
    x1 = x.dot(v1)
    v1x = x.scale(x1)
    v1y = v1.sub(v1x)
    
    x = x.scale(-1)
    
    v2 = c2.speed
    x2 = x.dot(v1)
    v2x = x.scale(x2)
    v2y = v2.sub(v2x)
    
    m1, m2 = c1.mass(), c2.mass()
    cm = m1 + m2
    
    nV1 = v1x.scale((m1 - m2) / cm).add(v2x.scale((2 * m2) / cm)).add(v1y)
    nV2 = v1x.scale((2 * m1) / cm).add(v2x.scale((m2 - m1) / cm)).add(v2y)
    
    c1.setSpeed(nV1)
    c2.setSpeed(nV2)
       '''
        
        
    

INF = 1000000000
def div(x, y):
    #x/y
    if y == 0:
        return INF
    if y > INF:
        return 0
    return x/y



'''
old util
import math

import CircleCollider
import game.phys.RectCollider as rect
import game.util.Vector2 as vector2


def circleToRect(c):
    pos = c.pos()
    r = c.radius
    return rect.RectCollider(None, pos.x, pos.y, r + r, r + r)

def rectToCircle(r):
    return CircleCollider.CircleCollider(None, r.pos().x, r.pos().y, r.radius())

def getCollisionPosition(r1, r2):
    hitRight = r2.left() - r1.right()  # distance between edges
    hitLeft = r1.left() - r2.right()  # distance between edge 
    
    
    if hitRight <= 0 and hitLeft <= 0:  # other box is bigger and box edges is inside the box
        hitRight, hitLeft = 0, 0
    
    hitTop = r2.top() - r1.bottom()
    hitBot = r1.top() - r2.bottom() 
    
    if hitTop <= 0 and hitBot <= 0:  # other box is bigger and box edges are inside
        hitTop, hitBot = 0, 0
    x = (-hitRight) if hitRight < 0 else (hitLeft if hitLeft < 0 else 0)
    y = (-hitBot)  if hitBot < 0 else (hitTop if hitTop < 0 else 0)
    
    if math.fabs(x) > math.fabs(y):
        x,y = x,0
    else:
        x,y = 0,y
    
    return (x, y)
  
  
def getCollisionPosition2(r1, r2):
    hitRight = r2.left() - r1.right()  # distance between edges
    hitLeft = r1.left() - r2.right()  # distance between edge 
    
    
    if hitRight <= 0 and hitLeft <= 0:  # other box is bigger and box edges is inside the box
        hitRight, hitLeft = 0, 0
    
    hitTop = r1.top() - r2.bottom()
    hitBot = r2.top() - r1.bottom() 
    
    if hitTop <= 0 and hitBot <= 0:  # other box is bigger and box edges are inside
        hitTop, hitBot = 0, 0
    x = (-hitRight) if hitRight < 0 else (hitLeft if hitLeft < 0 else 0)
    y = (-hitBot)  if hitBot < 0 else (hitTop if hitTop < 0 else 0)
    
    return (x, y)

def collideCircleCirlce(c1, c2):
    x = c1.pos().sub(c2.pos())
    x = x.normalize()
    v1 = c1.speed
    x1 = x.dot(v1)
    v1x = x.scale(x1)
    v1y = v1.sub(v1x)
    
    x = x.scale(-1)
    
    v2 = c2.speed
    x2 = x.dot(v1)
    v2x = x.scale(x2)
    v2y = v2.sub(v2x)
    
    m1, m2 = c1.mass(), c2.mass()
    cm = m1 + m2
    
    nV1 = v1x.scale((m1 - m2) / cm).add(v2x.scale((2 * m2) / cm)).add(v1y)
    nV2 = v1x.scale((2 * m1) / cm).add(v2x.scale((m2 - m1) / cm)).add(v2y)
    
    c1.setSpeed(nV1)
    c2.setSpeed(nV2)
    
def collideRectRect(r1, r2):
    hit = getCollisionPosition(r1, r2)
    m1 = r1.mass()
    m2 = r2.mass()
    mt = m1 + m2
    v1x, v1y, v2x, v2y = r1.speed.x, r1.speed.y, r2.speed.x, r2.speed.y
    if hit[0] != 0:  # hit right or left
        v1x = ((m1 - m2) / mt) * v1x + (2 * m2 / mt) * v2x
        v2x = ((2 * m2 / mt) * v1x) + ((m1 - m2) / mt) * v2x
    if hit[1] != 0:  # hit top or bot
        v1y = ((m1 - m2) / mt) * v1y + (2 * m2 / mt) * v2y
        v2y = ((2 * m2 / mt) * v1y) + ((m1 - m2) / mt) * v2y
    r1.setSpeed(vector2.Vector2(v1x, v1y))
    r2.setSpeed(vector2.Vector2(v2x, v2y))

def collideCircleRect(c1, r2):
    hit = getCollisionPosition2(circleToRect(c1), r2)
    m1 = c1.mass()
    m2 = r2.mass()
    mt = m1 + m2
    v1x, v1y, v2x, v2y = c1.speed.x, c1.speed.y, r2.speed.x, r2.speed.y
    
    
    if hit[0] != 0:  # hit right or left
        v1x = ((m1 - m2) / mt) * v1x + (2 * m2 / mt) * v2x
        v2x = ((2 * m2 / mt) * v1x) + ((m1 - m2) / mt) * v2x
    if hit[1] != 0:  # hit top or bot
        v1y = ((m1 - m2) / mt) * v1y + (2 * m2 / mt) * v2y
        v2y = ((2 * m2 / mt) * v1y) + ((m1 - m2) / mt) * v2y
    c1.setSpeed(vector2.Vector2(v1x, v1y))
    r2.setSpeed(vector2.Vector2(v2x, v2y))
'''
